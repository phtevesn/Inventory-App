/*
view schemas - \dn 
view tables - \dt 
view tables in one schema - \dt inv.*
view tables on all schemas - \dt *.*
view table structure - \d my_schema.users

SELECT * FROM my_schema.users;
SELECT username, email FROM my_schema.users;
SELECT * FROM my_schema.users LIMIT 10;

quit - \q

NEW TERMS
    serial: auto-incrementing integer
    identity: auto-incrementing
    big int: 64 bit
*/



create schema inv;

create table inv.users ( 
    userID bigint generated always as identity primary key,
    username text unique not null,
    password text not null,
    email text not null unique,
    created_at timestamptz not null default now(),
    updated_at timestamptz not null default now(),
    deleted_at timestamptz
);

create table inv.skeletons (
    skeleID bigint generated always as identity primary key, 
    skeleName text not null,
    imgPath text, 
    attributes jsonb not null default '{}'::jsonb,
    creatorID bigint, 
    posted boolean default false,
    created_at timestamptz not null default now(),
    updated_at timestamptz not null default now(),
    deleted_at timestamptz,

    constraint userCreatorFK
    foreign key (creatorID) references inv.users(userID) on delete set null on update cascade
);

create table inv.inventories(
    invID bigint generated always as identity primary key,
    invName text not null, 
    ownerID bigint not null,
    parentInvID bigint,
    imgPath text, 
    created_at timestamptz not null default now(), 
    updated_at timestamptz not null default now(),
    deleted_at timestamptz,
    
    constraint ownerFK
    foreign key (ownerID) references inv.users(userID) on delete restrict on update cascade, 
    constraint parentInvFK
    foreign key (parentInvID) references inv.inventories(invID) on delete cascade on update cascade
);

create table inv.folders(
    folderID bigint generated always as identity primary key,
    folderName text not null,
    invID bigint not null,
    parentFolderID bigint,
    imgPath text,
    created_at timestamptz not null default now(),
    updated_at timestamptz not null default now(),
    deleted_at timestamptz,

    constraint folderInv
    foreign key (invID) references inv.inventories(invID) on update cascade on delete cascade, 
    constraint parentFolder
    foreign key (parentFolderID) references inv.folders(folderID) on update cascade on delete cascade
);

create table inv.statuses(
    statusID bigint generated by default as identity primary key,
    statusName text not null, 
    imgPath text not null, 
    doesItCount boolean not null,
    creatorID bigint,

    constraint statusCreatorFK
    foreign key (creatorID) references inv.users(userID) on delete set null on update cascade
);

insert into inv.statuses (statusID, statusName, imgPath, doesItCount)
values
    (1, 'Ready', 'temp', true),
    (2, 'Not Ready', 'temp', false);

alter sequence inv.statuses_statusid_seq restart with 3;

create table inv.skeleInstances (
    skeleInstanceID bigint generated always as identity primary key,
    skeleID bigint not null, 
    invID bigint not null,
    folderID bigint, 
    count int not null,

    constraint skeleFK 
    foreign key (skeleID) references inv.skeletons(skeleID) on update restrict on delete restrict,
    constraint skeleInvFK
    foreign key (invID) references inv.inventories(invID) on update cascade on delete cascade,
    constraint skeleFolderFK
    foreign key (folderID) references inv.folders(folderID) on update set null on delete set null
);

create table inv.items(
    itemID bigint generated always as identity primary key, 
    skeleInstanceID bigint not null, 
    parentItemID bigint, 
    statusID bigint not null default 0, 
    creatorID bigint,
    attributes jsonb not null default '{}'::jsonb,
    notes text,
    created_at timestamptz not null default now(),
    updated_at timestamptz not null default now(),
    deleted_at timestamptz,

    constraint itemSkeleInstanceFK
    foreign key (skeleInstanceID) references inv.skeleInstances(skeleInstanceID) 
    on delete cascade on update cascade,
    foreign key (parentItemID) references inv.items(itemID) on delete set null on update cascade,
    constraint itemStatusFK
    foreign key (statusID) references inv.statuses(statusID) on delete set default on update cascade, 
    constraint itemCreatorFK
    foreign key (creatorID) references inv.users(userID) on delete set null on update cascade
);

create table inv.userRoles(
    roleID int primary key, 
    roleName text not null unique, 
    canUpDownSuper boolean not null default false, 
    canUpDownAdmin boolean not null default false, 
    canInvite boolean not null default false,
    canWrite boolean not null default false
);

insert into inv.userRoles
values 
    (1, 'owner', true, true, true, true),
    (2, 'super admin', false, true, true, true),
    (3, 'admin', false, false, true, true),
    (4, 'user', false, false, false, true);

create table inv.userInvs( 
    userID bigint not null,
    invID bigint not null,
    roleID int not null default 4,

    primary key(userID, invID),
    constraint userFK 
    foreign key (userID) references inv.users(userID) on delete cascade on update cascade,
    constraint invFK
    foreign key(invID) references inv.inventories(invID) on delete cascade on update cascade,
    constraint roleFK 
    foreign key(roleID) references inv.userroles(roleID) on delete set default on update cascade
);

create table inv.userSkelesFav (
    userID bigint not null,
    skeleID bigint not null,

    primary key(userID, skeleID),
    constraint userFK
    foreign key (userID) references inv.users(userID) on delete cascade on update cascade,
    constraint skeleFK
    foreign key (skeleID) references inv.skeletons(skeleID) on delete cascade on update cascade
);

create table inv.userStatusFav (
    userID bigint not null,
    statusID bigint not null,

    primary key(userID, statusID),
    constraint userFK
    foreign key (userID) references inv.users(userID) on delete cascade on update cascade,
    constraint statusFK
    foreign key (statusID) references inv.statuses(statusID) on delete cascade on update cascade
);

create table inv.skeleParents (
    skeleID bigint not null,
    parentSkeleID bigint not null, 
    
    primary key(skeleID, parentSkeleID),
    constraint skeleFK
    foreign key (skeleID) references inv.skeletons(skeleID) on delete cascade on update cascade,
    constraint parentSkeleFK
    foreign key (parentSkeleID) references inv.skeletons(skeleID) on delete cascade on update cascade
);

create table inv.skeleChildren (
    skeleID bigint not null,
    childSkeleID bigint not null, 
    
    primary key(skeleID, childSkeleID),
    constraint skeleFK
    foreign key (skeleID) references inv.skeletons(skeleID) on delete cascade on update cascade,
    constraint childSkeleFK
    foreign key (childSkeleID) references inv.skeletons(skeleID) on delete cascade on update cascade
);

create table inv.skeleFolders(
    skeleID bigint not null,
    folderID bigint not null,

    primary key (skeleID, folderID),
    constraint skeleFK 
    foreign key (skeleID) references inv.skeletons(skeleID) on delete cascade on update cascade,
    constraint skeleFolderFK
    foreign key (folderID) references inv.folders(folderID) on delete cascade on update cascade
);

create table inv.invSkeles(
    invID bigint not null,
    skeleID bigint not null,

    primary key(invID, skeleID),
    constraint invFK
    foreign key (invID) references inv.inventories(invID) on delete cascade on update cascade,
    constraint skeleFK
    foreign key (skeleID) references inv.skeletons(skeleID) on delete cascade on update cascade
);

create table inv.invStatuses(
    invID bigint not null,
    statusID bigint not null,

    primary key(invID, statusID),
    constraint invFK
    foreign key (invID) references inv.inventories(invID) on delete cascade on update cascade,
    constraint statusFK
    foreign key (statusID) references inv.statuses(statusID) on delete cascade on update cascade
);

create table inv.folderSkeles(
    folderID bigint not null,
    skeleInstanceID bigint not null,

    primary key(folderID, skeleInstanceID),
    constraint folderFK 
    foreign key (folderID) references inv.folders(folderID) on delete cascade on update cascade,
    constraint skeleInstancesFK
    foreign key (skeleInstanceID) references inv.skeleInstances(skeleInstanceID) on delete cascade on update cascade
);

